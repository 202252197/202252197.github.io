[{"id":"0debcd256996db7c9a3f68ed4dfb6299","title":"JAVA反射","content":"JAVA反射反射的常见作用\n1.动态加载类,动态获取类的信息(属性,方法,构造器)\n2.动态构造对象\n3.动态调用和外处理属性\n4.获取泛型信息\n5.处理注解\n\nClass类的对象如何获取？1.运用getClass()\n2.运用Class.forName()(最常被使用)\n3.运用.class语法\n\npackage jdk5;\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年4月2日 上午10:38:02   \n* @version\n */\npublic class reflection1 &#123;\n\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\n\t\t//第一种\n\t\tClass clazz=reflection1.class;\n\t\tSystem.out.println(clazz);\n\t\t//第二种\n\t\treflection1 reflection=new reflection1();\n\t\tClass clazz1 = reflection.getClass();\n\t\tSystem.out.println(clazz1);\n\t\t//第三种\n\t\tClass clazz2 = Class.forName(\"jdk5.reflection1\");\n\t\tSystem.out.println(clazz2);\n\t\t/**运行结果\n\t\t * class jdk5.reflection1\n\t\t   class jdk5.reflection1\n\t\t   class jdk5.reflection1\n\t\t */\n\t&#125;\n&#125;\n\n\n通过反射操作构造方法,方法,属性public class Student &#123;\n\tprivate int id;\n\tprivate String studentName;\n\tprivate int age;\n\tpublic int getId() &#123;\n\t\treturn id;\n\t&#125;\n\tpublic void setId(int id) &#123;\n\t\tthis.id = id;\n\t&#125;\n\tpublic String getStudentName() &#123;\n\t\treturn studentName;\n\t&#125;\n\tpublic void setStudentName(String studentName) &#123;\n\t\tthis.studentName = studentName;\n\t&#125;\n\tpublic int getAge() &#123;\n\t\treturn age;\n\t&#125;\n\tpublic void setAge(int age) &#123;\n\t\tthis.age = age;\n\t&#125;\n\t/* (non-Javadoc)\n\t * @see java.lang.Object#hashCode()\n\t */\n\t@Override\n\tpublic int hashCode() &#123;\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + age;\n\t\tresult = prime * result + id;\n\t\tresult = prime * result + ((studentName == null) ? 0 : studentName.hashCode());\n\t\treturn result;\n\t&#125;\n\t/* (non-Javadoc)\n\t * @see java.lang.Object#equals(java.lang.Object)\n\t */\n\t@Override\n\tpublic boolean equals(Object obj) &#123;\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tStudent other = (Student) obj;\n\t\tif (age != other.age)\n\t\t\treturn false;\n\t\tif (id != other.id)\n\t\t\treturn false;\n\t\tif (studentName == null) &#123;\n\t\t\tif (other.studentName != null)\n\t\t\t\treturn false;\n\t\t&#125; else if (!studentName.equals(other.studentName))\n\t\t\treturn false;\n\t\treturn true;\n\t&#125;\n\tpublic Student(int id, String studentName, int age) &#123;\n\t\tsuper();\n\t\tthis.id = id;\n\t\tthis.studentName = studentName;\n\t\tthis.age = age;\n\t&#125;\n\tpublic Student() &#123;\n\t\tsuper();\n\t&#125;\n&#125;\n\n\nimport static org.junit.Assert.assertArrayEquals;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.Optional;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n@SuppressWarnings(&#123;\"all\"&#125;)\npublic class Test2 &#123;\n\tpublic static void main(String[] args) throws ClassNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, NoSuchFieldException &#123;\n\t\tString student=\"jdk5.Student\";\n\t\tClass&lt;Student> forName = (Class&lt;Student>) Class.forName(student);\n\t\t//获取类的名字(Gets the name of the class)\n\t\tOptional.of(forName.getName()).ifPresent(System.out::println);//ClassName+PackageName\n\t\tOptional.of(forName.getSimpleName()).ifPresent(System.out::println);//ClassName\n\t\t//获取类的属性(Gets the attributes of the class)\n\t\tField[] fields = forName.getFields();//Gets the public attributes of the class\n\t\tOptional.of(fields.length).ifPresent(System.out::println);//Gets the arrays length of the private Field arrays;\n\t\tField[] declaredFields = forName.getDeclaredFields();//Gets all attributes of the class,return filed arrays;\n\t\tStream.of(declaredFields).forEach(System.out::println);\n\t\t//获取类的方法(Gets the Method of the class)\n\t\tMethod[] methods = forName.getMethods();//Gets the public Method of the Class and include extends Object of Method\n\t\tStream.of(methods).forEach(System.out::println);\n\t\n\t\tMethod[] declaredMethods = forName.getDeclaredMethods();//获取本类的所有方法\n\t\tStream.of(declaredMethods).forEach(System.out::println);\n\t\t\n\t\tMethod oneMethods=forName.getMethod(\"getStudentName\", null);//获取一个无参数的方法\n\t\tOptional.of(oneMethods).ifPresent(System.out::println);\n\t\t\n\t\tMethod method = forName.getMethod(\"setStudentName\", String.class);//获取一个有参数的方法\n\t\tOptional.of(method).ifPresent(System.out::println);\n\t\t//获取类的构造器\n\t\tConstructor&lt;?>[] constructors = forName.getConstructors();//获取此类的公开构造器\n\t\tOptional.of(Stream.of(constructors).collect(Collectors.toList()).parallelStream().map(v->v.toString()).reduce(\"\",(v1,v2)->v1+v2+\":构造方法\")).ifPresent(System.out::println);\n\t\tConstructor[] declaredConstructors = forName.getDeclaredConstructors();//获取此类的全部构造器\n\t\tOptional.of(Stream.of(declaredConstructors).collect(Collectors.toList()).parallelStream().map(v->v.toString()).reduce(\"\",(v1,v2)->v1+v2+\":构造方法\")).ifPresent(System.out::println);\n\t\tConstructor declaredConstructor = forName.getDeclaredConstructor(int.class,String.class,int.class);\n\t\tOptional.of(Stream.of(declaredConstructor).collect(Collectors.toList()).parallelStream().map(v->v.toString()).reduce(\"\",(v1,v2)->v1+v2+\":构造方法\")).ifPresent(System.out::println);\n\t\t//通过反射的API调用构造器,构造对象\n\t\tStudent newInstance = forName.newInstance();\n\t\tSystem.out.println(newInstance);\n\t\t\n\t\t//通过构造器调用实例,构造对象\n\t\tConstructor&lt;Student> constructor = forName.getConstructor(null);\n\t\tStudent newInstance2 = constructor.newInstance();\n\t\tSystem.out.println(newInstance2);\n\t\t\n\t\t//通过反射API调用方法\n\t\tMethod method2 = forName.getMethod(\"setStudentName\",String.class);\n\t\tmethod.invoke(newInstance2, \"ssss\");\n\t\tSystem.out.println(newInstance2.getStudentName());\n\t\t\n\t\t//通过反射API调用属性\n\t\tField declaredField = forName.getDeclaredField(\"id\");\n\t\t//设置之后代表不需要安全检查直接操作属性\n\t\tdeclaredField.setAccessible(true);\n\t\tdeclaredField.set(newInstance2, 666);\n\t\tSystem.out.println(newInstance2.getId());\n\t&#125;\n&#125;\n\n使用反射读取Pojo自定义注解自定义注解Tableimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(value= &#123;ElementType.TYPE&#125;)\npublic @interface Table &#123;\n\tString value();\n&#125;\n\n\n自定义注解Fieldimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target(value= &#123;ElementType.FIELD&#125;)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Field &#123;\n\tString columnName();\n\tString type();\n\tint length();\n&#125;\n\n\n自定Pojo类@Table(\"Studentx\")\npublic class Student &#123;\n\t@Field(columnName=\"id\",type=\"int\",length=10)\n\tprivate int id;\n\t@Field(columnName=\"studentName\",type=\"String\",length=100)\n\tprivate String studentName;\n\t@Field(columnName=\"age\",type=\"int\",length=10)\n\tprivate int age;\n\tpublic int getId() &#123;\n\t\treturn id;\n\t&#125;\n\tpublic void setId(int id) &#123;\n\t\tthis.id = id;\n\t&#125;\n\tpublic String getStudentName() &#123;\n\t\treturn studentName;\n\t&#125;\n\tpublic void setStudentName(String studentName) &#123;\n\t\tthis.studentName = studentName;\n\t&#125;\n\tpublic int getAge() &#123;\n\t\treturn age;\n\t&#125;\n\tpublic void setAge(int age) &#123;\n\t\tthis.age = age;\n\t&#125;\n&#125;\n\n读取注解应用import java.lang.reflect.Field;\nimport java.util.Optional;\nimport java.util.stream.Stream;\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年4月1日 下午1:40:45   \n* @version\n */\npublic class Test &#123;\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\n\t\tClass&lt;Student> forName = (Class&lt;Student>) Class.forName(\"jdk5.Student\");\n\t\tTable annotation = forName.getAnnotation(Table.class);\n\t\tStream&lt;Table> stream=Stream.of(annotation);\n\t\tstream.forEach(v->Optional.of(v.value()).ifPresent(System.out::println));\n\t\tField[] fields = forName.getDeclaredFields();\n\t\tStream&lt;Field> stream2=Stream.of(fields);\n\t\tstream2.map(v->v.getAnnotation(jdk5.Field.class)).forEach(v->Optional.of(v.columnName()+\"===\"+v.type()+\"===\"+v.length()).ifPresent(System.out::println));\n\t&#125;\n&#125;\n\nsetAccessible方法介绍启用和禁用访问安全检查的开关值为true则指示反射的对象在使用时应该取消Java语言访问检查。值为false则指示反射的对象应该实施Java语言访问检查。并不是为true就能访问为false就不能访问。禁止安全检查,可以提高反射的运行速度。\n\n通过反射获取方法的返回值和参数import java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Optional;\nimport java.util.stream.Stream;\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年4月2日 上午10:29:56   \n* @version\n */\npublic class Test5 &#123;\n\tpublic void get(ArrayList&lt;String> list,HashMap&lt;String,String> aas) &#123;\n\t\t\n\t&#125;\n\tpublic static void main(String[] args) throws NoSuchMethodException, SecurityException &#123;\n\t\tMethod declaredMethod = Test5.class.getDeclaredMethod(\"get\", ArrayList.class,HashMap.class);\n\t\t//获取方法的返回类型\n\t\tType genericReturnType = declaredMethod.getGenericReturnType();\n\t\tOptional.of(\"返回值类型:\"+genericReturnType).ifPresent(System.out::println);\n\t\t\n\t\t//获取方法的参数个数\n\t\tint parameterCount = declaredMethod.getParameterCount();\n\t\tOptional.of(\"参数个数:\"+parameterCount).ifPresent(System.out::println);\n\t\t\n\t\t//获取方法的参数类型\n\t\tType[] Types = declaredMethod.getParameterTypes();\n\t\tStream.of(Types).forEach(v->System.out.println(\"参数类型:\"+v.getTypeName()));\n\t\t\n\t&#125;\n&#125;\n\n通过反射运行编译好的类\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.net.URL;\nimport java.net.URLClassLoader;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年4月2日 下午2:41:29   \n* @version\n */\npublic class javaCompile &#123;\n\tpublic static void main(String[] args) throws IOException &#123;\n\t\ttry &#123;\n\t\t\tURL[] urlarr=new URL[] &#123;new URL(\"file:/\"+\"e:/\")&#125;;\n\t\t\tURLClassLoader newInstance = URLClassLoader.newInstance(urlarr);\n\t\t\tClass&lt;?> loadClass = newInstance.loadClass(\"lvshihao\");\n\t\t\tMethod method = loadClass.getMethod(\"main\", String[].class);\n\t\t\tmethod.invoke(loadClass,(Object)new String[] &#123;\"aa\"&#125;);\n\t\t\t//必须要将数组强转成对象要不然就会把数组当做一个可变参数传入\n\t\t&#125; catch (Exception e) &#123;\n\t\t\t// TODO: handle exception\n\t\t&#125;\n\t&#125;\n&#125;\n\nJava的动态编译\nJavaCompiler动态编译代码import java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport javax.tools.*;\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年4月2日 下午2:41:29   \n* @version\n */\npublic class javaCompile &#123;\n\tpublic static void main(String[] args) throws IOException &#123;\n\t\t//通过IO流生成临时文件 \n\t\tString str=\"public class lvshihao&#123; public static void main(String[] args) &#123;System.out.println('吕');&#125;&#125;\";\n\t\tFile file=new File(\"E:\\\\lvshihao.java\");\n\t\tif (!file.isFile()) &#123;\n\t\t\tfile.createNewFile();\n\t\t&#125;\n\t\tFileOutputStream fileOutputStream=new FileOutputStream(file);\n\t\tfileOutputStream.write(str.getBytes());\n\t\tfileOutputStream.close();\n\t\tJavaCompiler systemJavaCompiler = ToolProvider.getSystemJavaCompiler();\n\t\tint run = systemJavaCompiler.run(null, null, null,file.getAbsolutePath());\n\t\tSystem.out.println(run==0?\"编译成功\":\"编译失败\");\n\t\tfile.delete();\n\t&#125;\n&#125;\n\n\n动态运行编译好的类import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport javax.tools.*;\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年4月2日 下午2:41:29   \n* @version\n */\npublic class javaCompile &#123;\n\tpublic static void main(String[] args) throws IOException &#123;\n\t\t//通过IO流生成临时文件 \n\t\tString str=\"public class lvshihao&#123; public static void main(String[] args) &#123;System.out.println('吕');&#125;&#125;\";\n\t\tFile file=new File(\"E:\\\\lvshihao.java\");\n\t\tif (!file.isFile()) &#123;\n\t\t\tfile.createNewFile();\n\t\t&#125;\n\t\tFileOutputStream fileOutputStream=new FileOutputStream(file);\n\t\tfileOutputStream.write(str.getBytes());\n\t\tfileOutputStream.close();\n\t\tJavaCompiler systemJavaCompiler = ToolProvider.getSystemJavaCompiler();\n\t\tint run = systemJavaCompiler.run(null, null, null,file.getAbsolutePath());\n\t\tSystem.out.println(run==0?\"编译成功\":\"编译失败\");\n\t\tfile.delete();\n\t\tRuntime runtime=Runtime.getRuntime();\n\t\t//获取执行命令之后输出的流\n\t\tProcess exec = runtime.exec(\"java -cp e:/   lvshihao\");\n\t\tInputStream inputStream = exec.getInputStream();\n\t\tBufferedReader bufferedReader=new BufferedReader(new InputStreamReader(inputStream));\n\t\tString line=\"\";\n\t\twhile((line=bufferedReader.readLine())!=null) &#123;\n\t\t\tSystem.err.println(line);\n\t\t&#125;\n\t&#125;\n&#125;\n\n\n脚本引擎执行javascript代码-Rhino引擎\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.List;\nimport javax.script.Invocable;\nimport javax.script.ScriptEngine;\nimport javax.script.ScriptEngineManager;\nimport javax.script.ScriptException;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年4月2日 下午2:41:29   \n* @version\n */\npublic class javaCompile &#123;\n\tpublic static void main(String[] args) throws IOException, ScriptException, NoSuchMethodException &#123;\n\t\tScriptEngineManager scriptEngineManager=new ScriptEngineManager();\n\t\t//JDK11（弃用 Nashorn JavaScript 引擎）\n\t\tScriptEngine engineByName = scriptEngineManager.getEngineByName(\"js\");\n\t\t//定义变量,存储到引擎上下文中\n\t\tengineByName.put(\"msg\", \"lvshihao\");\n\t\tString ifno=\"var info=&#123;age:18,name:'吕世昊'&#125;;\"+\"print(info.name);\";\n\t\tengineByName.eval(ifno);\n\t\tengineByName.eval(\"msg='66666666';\");\n\t\tengineByName.eval(\"print(msg)\");\n\t\tSystem.out.println(engineByName.get(\"msg\"));\n\t\t//定义js方法\n\t\tengineByName.eval(\"function sum(a,b)&#123; return a+b;&#125;\");\n\t\t//执行js方法1\n\t\tengineByName.eval(\"print(sum(5,6));\");\n\t\t//执行js方法2\n\t\tInvocable invocable=(Invocable) engineByName;\n\t\tObject invokeFunction = invocable.invokeFunction(\"sum\", 5,6);\n\t\tSystem.out.println(invokeFunction);\n\t\t//导入其他java包,使用其他包中的java类\n\t\tString jsCode=\"var list=java.util.Arrays.asList([\\\"吕世昊\\\",\\\"最帅\\\"])\";\n\t\tengineByName.eval(jsCode);\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tList&lt;String> list = (List&lt;String>) engineByName.get(\"list\");\n\t\tfor (String string : list) &#123;\n\t\t\tSystem.out.println(string);\n\t\t&#125;\n\t\t//执行js文件(将a.js放置在src下)\n\t\tURL resource = javaCompile.class.getClassLoader().getResource(\"a.js\");\n\t\tFileReader fileReader=new FileReader(resource.getPath());\n\t\tengineByName.eval(fileReader);\n\t\tfileReader.close();\n\t&#125;\n&#125;\n\nfunction test()&#123;\n\tvar a=0;\n\tvar b=2;\n\tprint(a+b+\"a+b\");\n&#125;\ntest();\n\n注意事项\n一.jdk1.6的使用方法规则 1.8已经不适用了\nString jsCode = \"importPackage java.util; var list = Arrays.asList([\\\"爱你\\\",\\\"吕世昊\\\",\\\"最帅\\\"]);\";\n\n//jkd1.8的使用规则如下：\nString jsCode1 = \"var list = java.util.Arrays.asList([\\\"爱你\\\",\\\"吕世昊\\\",\\\"最帅\\\"]);\";\n\n二.如果出现 \"println\" is not defined in &lt;eval>,  则将\"println\"改\"print\"\n\n\n字节码操作javaassist库\n\n\n生产java字节码文件import java.io.IOException;\nimport javassist.CannotCompileException;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\nimport javassist.CtField;\nimport javassist.CtMethod;\nimport javassist.NotFoundException;\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年4月3日 下午1:02:01   \n* @version\n */\npublic class Test1 &#123;\n\tpublic static void main(String[] args) throws CannotCompileException, NotFoundException, IOException &#123;\n\t\tClassPool pool=ClassPool.getDefault();\n\t\tCtClass makeClass = pool.makeClass(\"Emp\");//构建一个名字为Emp的字节码类\n\t\t//创建属性\n\t\tCtField f1 = CtField.make(\"private int age;\", makeClass);\n\t\tCtField f2 = CtField.make(\"private String name;\", makeClass);\n\t\tmakeClass.addField(f1);\n\t\tmakeClass.addField(f2);\n\t\tCtMethod make = CtMethod.make(\"public void setAge(int age)&#123;this.age=age;&#125;\", makeClass);\n\t\tCtMethod make2 = CtMethod.make(\"public int getAge()&#123;return this.age;&#125;\", makeClass);\n\t\tCtMethod make3 = CtMethod.make(\"public void setName(String name)&#123;this.name=name;&#125;\", makeClass);\n\t\tCtMethod make4 = CtMethod.make(\"public String getName()&#123;return this.name;&#125;\", makeClass);\n\t\tmakeClass.addMethod(make);\n\t\tmakeClass.addMethod(make2);\n\t\tmakeClass.addMethod(make3);\n\t\tmakeClass.addMethod(make4);\n\t\t//添加构造器\n\t\tCtConstructor constructor=new CtConstructor(new CtClass[] &#123;CtClass.intType,pool.get(\"java.lang.String\")&#125;,makeClass);\n\t\tconstructor.setBody(\"&#123;this.age=age;this.name=name;&#125;\");\n\t\tmakeClass.addConstructor(constructor);\n\t\tmakeClass.writeFile(\"E:\\\\\");//将字节码写入到e盘\n\t\tSystem.out.println(\"字节码文件成成功\");\n\t&#125;\n&#125;\n\n\n常用的方法import java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport javassist.CannotCompileException;\nimport javassist.ClassClassPath;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport javassist.CtConstructor;\nimport javassist.CtField;\nimport javassist.CtMethod;\nimport javassist.NotFoundException;\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年4月3日 下午1:02:01   \n* @version\n */\nclass User1&#123;\n\t\n&#125;\npublic class Test1 &#123;\n\t@SuppressWarnings(\"deprecation\")\n\tpublic static void main(String[] args) throws CannotCompileException, NotFoundException, IOException, NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, InstantiationException &#123;\n\t\tClassPool pool=ClassPool.getDefault();\n\t\tpool.insertClassPath(new ClassClassPath(User1.class));\n\t\tCtClass ctClass = pool.get(User1.class.getName());\n\t\tString name = ctClass.getName();//获取这个类的包名+类名\n\t\tString simpleName = ctClass.getSimpleName();//获取这个类的类名\n\t\tCtClass superclass = ctClass.getSuperclass();//获取这个类的父类\n\t\tCtClass[] interfaces = ctClass.getInterfaces();//获取这个类的接口\n\t\tbyte[] bytecode = ctClass.toBytecode();//获取这个类的字节编码\n\t\tSystem.out.println(\"name:\"+name+\"==simpleName:\"+simpleName+\"==superclass:\"+simpleName+\"==interfaces:\"+interfaces+\"==tobytesCode:\"+bytecode.length);\n\t&#125;\n&#125;\n\n","slug":"java反射","date":"2023-04-04T06:58:11.672Z","categories_index":"","tags_index":"","author_index":"吕世昊"},{"id":"2d1512c57b77604216ac9cf1270a8ecb","title":"Java7新特性","content":"二进制字面量jdk7开始,终于可以用二进制来表示整数(byte,short,int和long)。\n使用二进制字面量的好处是,可以使代码更容易被理解。语法非常简单,\n只要在二进制数值前面加0b或0B\n举例：int x&#x3D;0B110110;\n\n数字字面量可以出现下划线为了增强对数值的阅读性,如我们经常把数据用逗号分隔一样，JK7提供了_对数值分隔。\n举例:int x&#x3D;1_000;\n注意事件:\n    不能出现在进制标识和数值之间\n    不能出现在数值开头和结尾\n    不能出现在小数点旁边\n\nswithc语句可以用字符串   String value&#x3D;&quot;吕世昊&quot;;\nswitch (value) &#123;\ncase &quot;吕世昊&quot;:\n\tSystem.out.println(&quot;嗯嗯他是人才&quot;);\n\tbreak;\ndefault:\n\tSystem.out.println(&quot;嗯嗯他是不人才&quot;);\n\tbreak;\n&#125;\n\n泛型简化&#x2F;&#x2F;后面的泛型类型可以不需要写,这叫泛型推断,也可以叫菱形泛型\nArrayList&lt;String&gt; arrayList&#x3D;new ArrayList&lt;&gt;();\n\n异常的多个catch合并Java 7之前的版本：\n如果用一个catch块处理多个异常，可以用管道符（|）将它们分开，在这种情况下异常参数变量（ex）是定义为final的，所以不能被修改。这一特性将生成更少的字节码并减少代码冗余。\nJava 7之前的版本：\ncatch (IOException ex) &#123;\n     logger.error(ex);\n     throw new MyException(ex.getMessage());\ncatch (SQLException ex) &#123;\n     logger.error(ex);\n     throw new MyException(ex.getMessage());\n&#125;catch (Exception ex) &#123;\n     logger.error(ex);\n     throw new MyException(ex.getMessage());\n&#125;\n在Java 7中，我们可以用一个catch块捕获所有这些异常：\ncatch(IOException | SQLException | Exception ex)&#123;\n     logger.error(ex);\n     throw new MyException(ex.getMessage());\n&#125;\n\ntry-with-resources语句格式:try(必须是java.lang.AutoCloseable的子类对象)&#123;...&#125;\n好处：\n    资源自动释放,不需要close()了\n    把需要关闭资源的部分都定义在这里就ok了\n    主要是沉体系的对象是这个接口的子类(看JDK7的API)\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月22日 下午1:48:41   \n* @version\n */\npublic class Test3 implements AutoCloseable&#123;\n\tpublic static void main(String[] args)  &#123;\n\t\t//1.7之后，只要实现了AutoCloseable接口\n\t\ttry(Test3 test=new Test3())&#123;\n\t\t\tSystem.out.println(\"--执行main方法--\");\n\t\t\tSystem.out.println(1/0);\n\t\t&#125;catch (Exception e) &#123;\n\t\t\tSystem.out.println(\"--exception--\");\n\t\t&#125;\n\t\tSystem.out.println(\"-------------------\");\n\t\t//JDK1.7之前,释放资源方式\n\t\ttry &#123;\n\t\t\tSystem.out.println(\"--执行main方法--\");\n\t\t\tSystem.out.println(1/0);\n\t\t&#125; catch (Exception e) &#123;\n\t\t\tSystem.out.println(\"--exception--\");\n\t\t&#125;finally &#123;\n\t\t\tSystem.out.println(\"--close--\");\n\t\t&#125;\n\t&#125;\n\n\t@Override\n\tpublic void close() throws Exception &#123;\n\t\t// TODO Auto-generated method stub\n\t\tSystem.out.println(\"close\");\n\t&#125;\n&#125;\n    \n\n","slug":"Java7新特性","date":"2023-04-04T06:57:12.756Z","categories_index":"","tags_index":"","author_index":"吕世昊"},{"id":"fb58890547580a34de2bb6837aa1cfff","title":"Java8新特性","content":"为何需要Lambda表达式1.在Java中,我们无法将函数作为参数传递给一个方法,也无法声明返回一个函数的方法\n2.在JavaScript中,函数参数是一个函数,返回值是另一个函数的情况是非常常见的; JavaScript是一门非常典型的函数式语言\n\n何为Lambada表达式Lambda: In programming languages such as Lisp, Python and Ruby lambda is an operator used to denote anonymous functions or closures, following the usage of lambda calculus。\n\nLambda表达式的基本结构java Lambda表达式是一种匿名函数;他是没有声明的方法,即没有访问修饰符,返回值声明和名字\njava中的Lambda表达式基本语法\n    (argument)-&gt;(body)\n比如说\n    (arg1,arg2..)-&gt;&#123;body&#125;\n    (type1 arg1,type2 arg2..)-&gt;&#123;body&#125;   \n\nFunctionalInterfacejava.lang.Functionallnterface\n表示所声明的接口为函数式接口\n如果不满足函数式接口的要求,则编译器报错\n并非必须,但凡满足函数式接口条件的接口,编译器均将其看作是函数式接口,即便没有添加Functionallnterface注解亦如此。\n\n关于函数式接口如果一个接口只有一个抽象方法,那么该接口就是一个函数式接口。\n如果我们在某个接口上声明了FunctionalInterface注解,那么编译器就会按照函数式接口的定义来要求该接口\n如果某个接口只有一个抽象方法,但我们并没有给接口声明FunctionalInterface注解,那么该编译器依旧会将该接口看做是函数式接口。\n\n并行流与串行流并行流就是把一个内容分成多个数据块,并用不同的线程分别处理每个数据块的流,相比较串行的流,并行的流可以很大程度上提高程序的执行效率。\njava8中将并行进行了优化,我们可以很容易的对数据进行并行操作。Stream API可以声明性通过parallel()与sequential()在并行流与顺序流之间进行切换\n\nLambda示例说明Lambda示例说明\n(int a,int b)-&gt;&#123;return a+b&#125;\n()-&gt;System.out.println(&quot;Hello World&quot;)\n(String s)-&gt;&#123;System.out.println(s);&#125;\n()-&gt;42\n()-&gt;&#123;return 3.1415&#125;;\n\nLambda结构一个Lambda表达式可以有零个或多个参数\n参数的类型既可以明确声明,也可以根据上下文来推断。例如:(int a)与(a)效果相同\n所有参数需包含在圆括号内,参数之间用逗号相隔。例如:(a,b)或(int a,int b)或(String a,int b,float c)\n空圆括号代表参数为空。例如:()-&gt;42\n当只有一个参数,且类型可推导时,圆括号&#123;&#125;可以省略。例如:a-&gt;return a*a\nLambda表达式的主体可包含零条或多条语句\n如果Lambda表达式的主体只有一条语句,花括号&#123;&#125;可以省略。匿名函数的返回类型与该主体表达式一致\n如果Lambda表达式的主体包含一条以上语句,则表达式必须包含在花括号&#123;&#125;中(形成代码块)。匿名函数的返回类型与代码块的返回类型一致,若没有返回则为空\n\nLambda表达式作用Lambda表达式为java添加了缺失的函数式编程特性,使我们将函数当做一等公民看待\n在将函数作为一等公民的语言中,Lambda表达式的类型就是函数。但在java中,Lambda表达式是对象,他们必须依附于一类特别的对象类型——函数式接口(functional interface)\n\nLambda流的基本使用public static void main(String[] args) &#123;\n\t\tList&lt;String> list=Arrays.asList(\"lvshihao\",\"i love\",\"zhang\");\n\t\tlist.stream().map(item->item.toUpperCase()).forEach(System.out::println);\n\t\tlist.stream().map(String::toUpperCase).forEach(System.out::println);\n\t&#125;\n\nLambda排序使用public static void main(String[] args) &#123;\n\t\tList&lt;String> list=Arrays.asList(\"lvshihao\",\"i love\",\"zhang\");\n\t\tCollections.sort(list,(o1,o2)->o1.compareTo(o2));\n\t\tlist.stream().map(String::toUpperCase).forEach(System.out::println);\n\t&#125;\n\n函数式接口的使用Function接口详解import java.util.function.Function;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月25日 下午1:01:06   \n* @version\n */\npublic class FunctionTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tint compat = mycompose(2, value->value*3, value->value*value);\n\t\tint compat2 = myandThen(2, value->value*3, value->value*value);\n\t\tint compat3 =myapply(3,value->value*8);\n\t\tSystem.out.println(compat);\n\t\tSystem.out.println(compat2);\n\t\tSystem.out.println(compat3);\n\t&#125;\n\tpublic static int myapply(int a,Function&lt;Integer, Integer> function) &#123;\n\t\treturn function.apply(a);\n\t&#125;\n\tpublic static int mycompose(int a,Function&lt;Integer, Integer> function,Function&lt;Integer, Integer> function2) &#123;\n\t\t/**\n\t\t *  default &lt;V> Function&lt;V, R> compose(Function&lt;? super V, ? extends T> before) &#123;\n\t\t        Objects.requireNonNull(before);\n\t\t        return (V v) -> apply(before.apply(v));\n\t\t    &#125;\n\t\t * 1.首先调用第一个函数的compose方法将第二个函数传入进去\n\t\t * 2.首先Objects.requireNonNull(before);判断一下此对象是否为空\n\t\t * 3.首先看before.apply(v),先计算的是第二个函数的apply方法也就是v*v\n\t\t * 4.然后计算得出的结果在给第一个函数的apply传入进去,然后返回这个函数\n\t\t * 5.再调用第一个函数的apply进行计算\n\t\t */\n\t\treturn function.compose(function2).apply(a);\n\t&#125;\n\tpublic static int myandThen(int a,Function&lt;Integer, Integer> function,Function&lt;Integer, Integer> function2) &#123;\n\t\t/**\n\t\t * 和上面一样只不过就是反着先计算第一个,在计算第二个函数\n\t\t */\n\t\treturn function.andThen(function2).apply(a);\n\t&#125;\n&#125;\n\nBiFunction函数式接口详解import java.util.function.BiFunction;\nimport java.util.function.Function;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月25日 下午1:22:11   \n* @version\n */\npublic class BiFunctionTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tint apply = apply(5, 1, (value1,value2)->value1*value2);\n\t\tSystem.out.println(apply);\n\t\tint myandThen = myandThen(2, 3,(value1,value2)->value1+value2, value->value*2);\n\t\tSystem.out.println(myandThen);\n\t\t//&lt;P>思考BiFunctionTest为什么没有compose这个默认方法,很容易理解,\n\t\t//想想你先计算的是一个&lt;em>function OR bifunction&lt;/em>,也就是只返回一个值,\n\t\t//那么怎么可能再执行第二个bifunction呢&lt;/P>\n\t&#125;\n\tpublic static int apply(int a,int b,BiFunction&lt;Integer, Integer, Integer> function) &#123;\n\t\treturn function.apply(a, b);\n\t&#125;\n\tpublic static int myandThen(int a,int b,BiFunction&lt;Integer, Integer, Integer> function,Function&lt;Integer,Integer> function2) &#123;\n\t\treturn function.andThen(function2).apply(a, b);\n\t&#125;\n&#125;\n\nBiFunction函数式接口实例import java.util.Arrays;\nimport java.util.List;\nimport java.util.function.BiFunction;\nimport java.util.stream.Collectors;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月25日 下午2:03:08   \n* @version\n */\npublic class BiFunctionInstance &#123;\n\tpublic static void main(String[] args) throws ClassNotFoundException &#123;\n\t\tPerson person=new Person(\"lvshihao\",17);\n\t\tPerson person2=new Person(\"xiaoming\", 15);\n\t\tPerson person3=new Person(\"zhangying\", 17);\n\t\tList&lt;Person> list=Arrays.asList(person,person2,person3);\n\t\tList&lt;Person> searchAge = searchAge(15,list);\n\t\tList&lt;Person> searchUserName = searchUserName(\"lvshihao\", list);\n\t\tsearchUserName.forEach(value->&#123;System.out.println(value.getUserName());&#125;);\n\t\tsearchAge.forEach(value->&#123;System.out.println(value.getUserName());&#125;);\n\t\t\n\t\t\n\t\tList&lt;Person> searchAge2 = searchAge2(15, list,(v,v1)->v1.stream().filter(value->value.getAge()>v).collect(Collectors.toList()));\n\t\tsearchAge2.forEach(value->System.out.println(value.getUserName()));\n\t\t\n\t&#125;\n\tpublic static List&lt;Person> searchUserName(String userName,List&lt;Person> list)&#123;\n\t\treturn list.stream().filter(item->item.getUserName().equals(userName))\n\t\t\t\t.collect(Collectors.toList());\n\t&#125;\n\tpublic static List&lt;Person> searchAge(int age,List&lt;Person> list)&#123;\n\t\tBiFunction&lt;Integer, List&lt;Person>, List&lt;Person>> biFunction=(v,v1)->\n\t\t\tv1.stream().filter(person->person.getAge()>age)\n\t\t\t.collect(Collectors.toList());\n\t\t;\n\t\treturn biFunction.apply(age, list);\n\t&#125;\n\tpublic static List&lt;Person> searchAge2(int age,List&lt;Person> list,BiFunction&lt;Integer, List&lt;Person>, List&lt;Person>> bifunction)&#123;\n\t\treturn bifunction.apply(age, list);\n\t&#125;\n&#125;\nclass Person&#123; \n\tpublic Person(String userName,int age) &#123;\n\t\tsetUserName(userName);\n\t\tsetAge(age);\n\t&#125;\n\tprivate String userName;\n\tprivate int age;\n\t/**\n\t * @return the userName\n\t */\n\tpublic String getUserName() &#123;\n\t\treturn userName;\n\t&#125;\n\t/**\n\t * @param userName the userName to set\n\t */\n\tpublic void setUserName(String userName) &#123;\n\t\tthis.userName = userName;\n\t&#125;\n\t/**\n\t * @return the age\n\t */\n\tpublic int getAge() &#123;\n\t\treturn age;\n\t&#125;\n\t/**\n\t * @param age the age to set\n\t */\n\tpublic void setAge(int age) &#123;\n\t\tthis.age = age;\n\t&#125;\n&#125;\n\nPredicate函数式接口使用实例import java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月25日 下午3:28:09   \n* @version\n */\npublic class PredicateTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tPredicate&lt;String> predicate=value->value.length()>5;\n\t\tboolean test = predicate.test(\"lo\");\n\t\tSystem.out.println(test);\n\t\t\n\t\tList&lt;Integer> list=Arrays.asList(1,2,3,4,5,6,7,8,9,10);\n\t\t\n\t\tconditionFilter(list,(value)->value%2==0);\n\t\tSystem.out.println(\"------------------\");\n\t\tconditionFilter2(list,(value)->value%3==0);\n\t\tSystem.out.println(\"------------------\");\n\t\tconditionFilterAnd(list, v->v>5, v->v%3==0);\n\t\tSystem.out.println(\"------------------\");\n\t\tconditionFilterOR(list, v->v>5,v-> v%3==0);\n\t\tSystem.out.println(\"------------------\");\n\t\tconditionFilterAndSumNegate(list, v->v>5, v->v%3==0);\n\t\tSystem.out.println(\"------------------\");\n\t\tPredicate&lt;Object> conditionisEqual = conditionisEqual(\"lvshihao\");\n\t\tboolean test2 = conditionisEqual.test(\"lvshihao\");\n\t\tSystem.out.println(test2);\n\t&#125;\n\n\tpublic static void conditionFilter(List&lt;Integer> list,Predicate&lt;Integer> predicate) &#123;\n\t\tfor (int i = 0; i &lt;=list.size(); i++) &#123;\n\t\t\tif(predicate.test(i)) &#123;\n\t\t\t\tSystem.out.println(i);\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n\tpublic static void conditionFilter2(List&lt;Integer> list,Predicate&lt;Integer> predicate) &#123;\n\t\tList&lt;Integer> collect = list.stream().filter(predicate).collect(Collectors.toList());\n\t\tcollect.forEach(System.out::println);\n\t&#125;\n\t\n\tpublic static void conditionFilterAnd(List&lt;Integer> list,Predicate&lt;Integer> predicate,Predicate&lt;Integer> predicate2) &#123;\n\t\tList&lt;Integer> collect = list.stream().filter(v->predicate.and(predicate2).test(v)).collect(Collectors.toList());\n\t\tcollect.forEach(System.out::println);\n\t&#125;\n\t\n\tpublic static void conditionFilterOR(List&lt;Integer> list,Predicate&lt;Integer> predicate,Predicate&lt;Integer> predicate2) &#123;\n\t\tList&lt;Integer> collect = list.stream().filter(v->predicate.or(predicate2).test(v)).collect(Collectors.toList());\n\t\tcollect.forEach(System.out::println);\n\t&#125;\n\t\n\tpublic static void conditionFilterAndSumNegate(List&lt;Integer> list,Predicate&lt;Integer> predicate,Predicate&lt;Integer> predicate2) &#123;\n\t\tList&lt;Integer> collect = list.stream().filter(v->predicate.and(predicate2).negate().test(v)).collect(Collectors.toList());\n\t\tcollect.forEach(System.out::println);\n\t&#125;\n\tpublic static Predicate&lt;Object> conditionisEqual(String name) &#123;\n\t\treturn \tPredicate.isEqual(name);\n\t&#125;\n&#125;\n\nSupplier函数式接口使用实例import java.util.function.Supplier;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月25日 下午6:28:09   \n* @version\n */\n\npublic class SupplierTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tSupplier&lt;String> supplier=()->\"Hellow LVSHIHAO\";\n\t\tSystem.out.println(supplier.get());\n\t\tSupplier&lt;Student> supplier2=()->new Student(\"lvshihao\",15);\n\t\tSystem.out.println(supplier2.get().getName());\n\t\tSupplier&lt;Student> supplier3=Student::new;\n\t\tSystem.out.println(supplier3.get().getName());\n\t&#125;\n&#125;\nclass Student&#123;\n\tprivate String name;\n\tprivate int age;\n\tpublic Student() &#123;\n\t\t// TODO Auto-generated constructor stub\n\t\tsetName(\"lvshihao I Love You\");\n\t\tsetAge(18);\n\t&#125;\n\tpublic Student(String name,int age) &#123;\n\t\t// TODO Auto-generated constructor stub\n\t\tsetName(name);\n\t\tsetAge(age);\n\t&#125;\n\t/**\n\t * @return the name\n\t */\n\tpublic String getName() &#123;\n\t\treturn name;\n\t&#125;\n\t/**\n\t * @param name the name to set\n\t */\n\tpublic void setName(String name) &#123;\n\t\tthis.name = name;\n\t&#125;\n\t/**\n\t * @return the age\n\t */\n\tpublic int getAge() &#123;\n\t\treturn age;\n\t&#125;\n\t/**\n\t * @param age the age to set\n\t */\n\tpublic void setAge(int age) &#123;\n\t\tthis.age = age;\n\t&#125;\n\t\n&#125;\n\nBinaryOperator函数式接口使用import java.util.function.BinaryOperator;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月25日 下午6:55:52   \n* @version\n */\npublic class BinaryOperatorTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tBinaryOperator&lt;Integer> binaryOperator=(v1,v2)->v1*v2;\n\t\tInteger apply = binaryOperator.apply(5, 7);\n\t\tSystem.out.println(apply);\n\t\tInteger apply2 = BinaryOperator.minBy((Integer o1,Integer o2)-> o1-o2).apply(5, 3);\n\t\tSystem.out.println(apply2);\n\t\tInteger apply3 = BinaryOperator.maxBy((Integer o1,Integer o2)-> o1-o2).apply(5, 3);\n\t\tSystem.out.println(apply3);\n\t\t\n\t\tSystem.out.println(\"-----------------\");\n\t\tSystem.out.println(getShort(5, 6,BinaryOperator.minBy((v1,v2)->v1-v2)));\n\t\tSystem.out.println(getLong(5, 6,BinaryOperator.maxBy((v1,v2)->v1-v2)));\n\t&#125;\n\tpublic static int getShort(int a,int b,BinaryOperator&lt;Integer> binaryOperator) &#123;\n\t\treturn binaryOperator.apply(a, b);\n\t&#125;\n\tpublic static int getLong(int a,int b,BinaryOperator&lt;Integer> binaryOperator) &#123;\n\t\treturn binaryOperator.apply(a, b);\n\t&#125;\n&#125;\n\nOptional类详解import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Optional;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月25日 下午8:05:25   \n* @version\n */\npublic class OptionalTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\t//构造一个空值Optional对象\n\t\tOptional&lt;String> optional=Optional.empty();\n\t\tif(!optional.isPresent()) &#123;\n\t\t\tSystem.out.println(\"没有值\");\n\t\t&#125;\n\t\t//构造一个包含lvshihao值的Optional对象\n\t\tOptional&lt;String> optional2=Optional.of(\"lvshihao\");\n\t\tif(optional2.isPresent()/*判断此对象的值是否为空*/) &#123;\n\t\t\tString string = optional2.get();//获取此对象容器的值\n\t\t\tSystem.out.println(string);\n\t\t&#125;\n\t\t//如果像上面这种写法和普通判断值是否为空操作一样所有没有上面简单的\n\t\t//下面采用Lambda表达式(推荐使用)\n\t\tOptional&lt;String> optional3=Optional.of(\"lvshihao I Love You\");\n\t\toptional3.ifPresent(System.out::println);\n\t\t\n\t\t//意思是如果optional没有值就会输出当前的值\n\t\tSystem.out.println(optional.orElse(\"没有值\"));\n\t\t\n\t\t//意思是如果optional没有值就会输出当前的值,但是支持Lambda表达式\n\t\tSystem.out.println(optional.orElseGet(()->\"没有值\"));\n\t\t\n\t\t//此方法用于不知道传入进来的值是否为空\n\t\tOptional&lt;String> optional4=Optional.ofNullable(\"555\");\n\t\toptional4.ifPresent(System.out::println);\n\t\t\n\t\t//使用map判断对象是否为空,为空则返回空,否则返回当前集合\n\t\tEmployee employee=new Employee();\n\t\temployee.setName(\"lvshihao\");\n\t\t\n\t\tEmployee employee1=new Employee();\n\t\temployee.setName(\"zhangying\");\n\t\t\n\t\tCompany company=new Company();\n\t\tList&lt;Employee> list=Arrays.asList(employee,employee1);\n\t\tcompany.setEmployees(list);\n\t\tOptional&lt;Company> optional5=Optional.ofNullable(company);\n\t\tSystem.out.println(optional5.map(theCompany->theCompany.getEmployees()).orElse(Collections.emptyList()));\n\t&#125;\n&#125;\n\nclass Company&#123;\n\tprivate String name;\n\tprivate List&lt;Employee> employees;\n\t/**\n\t * @return the name\n\t */\n\tpublic String getName() &#123;\n\t\treturn name;\n\t&#125;\n\t/**\n\t * @param name the name to set\n\t */\n\tpublic void setName(String name) &#123;\n\t\tthis.name = name;\n\t&#125;\n\t/**\n\t * @return the employees\n\t */\n\tpublic List&lt;Employee> getEmployees() &#123;\n\t\treturn employees;\n\t&#125;\n\t/**\n\t * @param employees the employees to set\n\t */\n\tpublic void setEmployees(List&lt;Employee> employees) &#123;\n\t\tthis.employees = employees;\n\t&#125;\n\t\n&#125;\n\nclass Employee&#123;\n\tprivate String name;\n\n\t/**\n\t * @return the name\n\t */\n\tpublic String getName() &#123;\n\t\treturn name;\n\t&#125;\n\n\t/**\n\t * @param name the name to set\n\t */\n\tpublic void setName(String name) &#123;\n\t\tthis.name = name;\n\t&#125;\n&#125;\n\n\n方法引用1.当要传递给Lambda体的操作,已经有实现的方法了,可以使用方法引用!\n2.方法引用可以看做是Lambda表达式深层次的表达。换句话说,方法引用就是Lambda表达式,也就是函数式接口的一个实例,通过方法的名字来指向个方法,可以认为是Lambda表达式的一个语法糖。\n3.要求:实现接口的抽象方法的参数列表和返回值类型,必须与方法引用的 ,方法的参数列表和返回值类型保持一致!\n格式:使用操作符&quot;::&quot;将类(或对象)与方法名分隔开来。\n如下三种主要使用情况:\n对象::实例方法名\n类:静态方法名\n类:实例方法名\n\n类名::静态方法名import java.util.Arrays;\nimport java.util.List;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月25日 下午8:45:52   \n* @version\n */\npublic class MethodReference &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tStudente studente1=new Studente(\"lvshihao\",44);\n\t\tStudente studente2=new Studente(\"liuxinyu\",25);\n\t\tStudente studente3=new Studente(\"zhangying\",12);\n\t\tStudente studente4=new Studente(\"guoyayu\",2);\n\t\tList&lt;Studente> list=Arrays.asList(studente1,studente2,studente3,studente4);\n\t\tlist.sort((v1,v2)->Studente.compareStudentByScore(v1,v2));\n\t\tlist.forEach((v)->System.out.println(v.getScore()));\n\t\t\n\t\t\n\t\tlist.sort((v1,v2)->Studente.compareStudentByName(v1,v2));\n\t\tlist.forEach((v)->System.out.println(v.getName()));\n\t\tSystem.out.println(\"---------------\");\n\t\t//使用静态方法引用的方式\n\t\tlist.sort(Studente::compareStudentByScore);\n\t\tlist.forEach((v)->System.out.println(v.getScore()));\n\t\t\n\t\tlist.sort(Studente::compareStudentByName);\n\t\tlist.forEach((v)->System.out.println(v.getName()));\n\t&#125;\n\t\n&#125;\nclass Studente&#123;\n\tprivate String name;\n\tprivate int score;\n\tpublic Studente(String name, int score) &#123;\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.score = score;\n\t&#125;\n\t/**\n\t * @return the name\n\t */\n\tpublic String getName() &#123;\n\t\treturn name;\n\t&#125;\n\t/**\n\t * @param name the name to set\n\t */\n\tpublic void setName(String name) &#123;\n\t\tthis.name = name;\n\t&#125;\n\t/**\n\t * @return the score\n\t */\n\tpublic int getScore() &#123;\n\t\treturn score;\n\t&#125;\n\t/**\n\t * @param score the score to set\n\t */\n\tpublic void setScore(int score) &#123;\n\t\tthis.score = score;\n\t&#125;\n\tpublic static int compareStudentByScore(Studente student1,Studente student2) &#123;\n\t\treturn student1.getScore()-student2.getScore();\n\t&#125;\n\tpublic static int compareStudentByName(Studente student1,Studente student2) &#123;\n\t\treturn student1.getName().compareToIgnoreCase(student2.getName());\n\t&#125;\n&#125;\n\n引用名（对象名）::实例方法名import java.util.Arrays;\nimport java.util.List;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月25日 下午8:45:52   \n* @version\n */\npublic class MethodReference &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tStudente studente1=new Studente(\"lvshihao\",44);\n\t\tStudente studente2=new Studente(\"liuxinyu\",25);\n\t\tStudente studente3=new Studente(\"zhangying\",12);\n\t\tStudente studente4=new Studente(\"guoyayu\",2);\n\t\tList&lt;Studente> list=Arrays.asList(studente1,studente2,studente3,studente4);\n\t\tlist.sort((v1,v2)->Studente.compareStudentByScore(v1,v2));\n\t\tlist.forEach((v)->System.out.println(v.getScore()));\n\t\t\n\t\t\n\t\tlist.sort((v1,v2)->Studente.compareStudentByName(v1,v2));\n\t\tlist.forEach((v)->System.out.println(v.getName()));\n\t\tSystem.out.println(\"---------------\");\n\t\t//使用实例方法引用的方式\n\t\tStudentComparator studentComparator=new StudentComparator();\n\t\tlist.sort(studentComparator::compareStudentByScore);\n\t\tlist.forEach((v)->System.out.println(v.getScore()));\n\t\t\n\t\tlist.sort(studentComparator::compareStudentByName);\n\t\tlist.forEach(v->System.out.println(v.getName()));\n\t&#125;\n\t\n&#125;\nclass StudentComparator&#123;\n\tpublic int compareStudentByScore(Studente student1,Studente student2) &#123;\n\t\treturn student1.getScore()-student2.getScore();\n\t&#125;\n\tpublic int compareStudentByName(Studente student1,Studente student2) &#123;\n\t\treturn student1.getName().compareToIgnoreCase(student2.getName());\n\t&#125;\n&#125;\nclass Studente&#123;\n\tprivate String name;\n\tprivate int score;\n\tpublic Studente(String name, int score) &#123;\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.score = score;\n\t&#125;\n\t/**\n\t * @return the name\n\t */\n\tpublic String getName() &#123;\n\t\treturn name;\n\t&#125;\n\t/**\n\t * @param name the name to set\n\t */\n\tpublic void setName(String name) &#123;\n\t\tthis.name = name;\n\t&#125;\n\t/**\n\t * @return the score\n\t */\n\tpublic int getScore() &#123;\n\t\treturn score;\n\t&#125;\n\t/**\n\t * @param score the score to set\n\t */\n\tpublic void setScore(int score) &#123;\n\t\tthis.score = score;\n\t&#125;\n\tpublic static int compareStudentByScore(Studente student1,Studente student2) &#123;\n\t\treturn student1.getScore()-student2.getScore();\n\t&#125;\n\tpublic static int compareStudentByName(Studente student1,Studente student2) &#123;\n\t\treturn student1.getName().compareToIgnoreCase(student2.getName());\n\t&#125;\n&#125;\n\n类名::实例方法名import java.util.Arrays;\nimport java.util.List;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月25日 下午8:45:52   \n* @version\n */\npublic class MethodReference &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tStudente studente1=new Studente(\"lvshihao\",44);\n\t\tStudente studente2=new Studente(\"liuxinyu\",25);\n\t\tStudente studente3=new Studente(\"zhangying\",12);\n\t\tStudente studente4=new Studente(\"guoyayu\",2);\n\t\tList&lt;Studente> list=Arrays.asList(studente1,studente2,studente3,studente4);\n\t\tlist.sort((v1,v2)->Studente.compareStudentByScore(v1,v2));\n\t\tlist.forEach((v)->System.out.println(v.getScore()));\n\t\t\n\t\t\n\t\tlist.sort((v1,v2)->Studente.compareStudentByName(v1,v2));\n\t\tlist.forEach((v)->System.out.println(v.getName()));\n\t\tSystem.out.println(\"---------------\");\n\t\t//使用类名的实例方法\n\t\t//第一个参数就是这个Studente,第二个Studente是传进去的参数\n\t\tlist.sort(Studente::compareByScore);\n\t\tlist.forEach((v)->System.out.println(v.getScore()));\n\t\t\n\t\tlist.sort(Studente::compareByName);\n\t\tlist.forEach(v->System.out.println(v.getName()));\n\t\tSystem.out.println(\"--------------------\");\n\t\t//比如\n\t\tList&lt;String> list2=Arrays.asList(\"lvshihoa\",\"kks\",\"aas\");\n\t\tlist2.sort(String::compareToIgnoreCase);\n\t\tlist2.forEach(System.out::println);\n\t&#125;\n\t\n&#125;\nclass StudentComparator&#123;\n\tpublic int compareStudentByScore(Studente student1,Studente student2) &#123;\n\t\treturn student1.getScore()-student2.getScore();\n\t&#125;\n\tpublic int compareStudentByName(Studente student1,Studente student2) &#123;\n\t\treturn student1.getName().compareToIgnoreCase(student2.getName());\n\t&#125;\n&#125;\nclass Studente&#123;\n\tprivate String name;\n\tprivate int score;\n\tpublic Studente(String name, int score) &#123;\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.score = score;\n\t&#125;\n\t/**\n\t * @return the name\n\t */\n\tpublic String getName() &#123;\n\t\treturn name;\n\t&#125;\n\t/**\n\t * @param name the name to set\n\t */\n\tpublic void setName(String name) &#123;\n\t\tthis.name = name;\n\t&#125;\n\t/**\n\t * @return the score\n\t */\n\tpublic int getScore() &#123;\n\t\treturn score;\n\t&#125;\n\t/**\n\t * @param score the score to set\n\t */\n\tpublic void setScore(int score) &#123;\n\t\tthis.score = score;\n\t&#125;\n\tpublic static int compareStudentByScore(Studente student1,Studente student2) &#123;\n\t\treturn student1.getScore()-student2.getScore();\n\t&#125;\n\tpublic static int compareStudentByName(Studente student1,Studente student2) &#123;\n\t\treturn student1.getName().compareToIgnoreCase(student2.getName());\n\t&#125;\n\tpublic int compareByScore(Studente student1) &#123;\n\t\treturn this.getScore()-student1.getScore();\n\t&#125;\n\tpublic int compareByName(Studente student1) &#123;\n\t\treturn this.getName().compareTo(student1.getName());\n\t&#125;\n&#125;\n\n构造方法引用(类名::new)import java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月25日 下午8:45:52   \n* @version\n */\npublic class MethodReference &#123;\n\t\n\tpublic static void main(String[] args) &#123;\n\t\tStudente studente1=new Studente(\"lvshihao\",44);\n\t\tStudente studente2=new Studente(\"liuxinyu\",25);\n\t\tStudente studente3=new Studente(\"zhangying\",12);\n\t\tStudente studente4=new Studente(\"guoyayu\",2);\n\t\tList&lt;Studente> list=Arrays.asList(studente1,studente2,studente3,studente4);\n\t\tlist.sort((v1,v2)->Studente.compareStudentByScore(v1,v2));\n\t\tlist.forEach((v)->System.out.println(v.getScore()));\n\t\t\n\t\t\n\t\tlist.sort((v1,v2)->Studente.compareStudentByName(v1,v2));\n\t\tlist.forEach((v)->System.out.println(v.getName()));\n\t\tSystem.out.println(\"---------------\");\n\t\t//构造方法引用(类名::new)\n\t\tString toString = getToString(String::new);\n\t\tSystem.out.println(toString);\n\t\tString toString2=getToString2(String::new);\n\t\tSystem.out.println(toString2);\n\t\t\n\t&#125;\n\tpublic static String getToString(Supplier&lt;String> supplier) &#123;\n\t\treturn supplier.get()+\"吕世昊\";\n\t&#125;\n\tpublic static String getToString2(Function&lt;String, String> function) &#123;\n\t\treturn function.apply(\"aaaaaa\")+\"吕世昊\";\n\t&#125;\n&#125;\nclass StudentComparator&#123;\n\tpublic int compareStudentByScore(Studente student1,Studente student2) &#123;\n\t\treturn student1.getScore()-student2.getScore();\n\t&#125;\n\tpublic int compareStudentByName(Studente student1,Studente student2) &#123;\n\t\treturn student1.getName().compareToIgnoreCase(student2.getName());\n\t&#125;\n&#125;\nclass Studente&#123;\n\tprivate String name;\n\tprivate int score;\n\tpublic Studente(String name, int score) &#123;\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.score = score;\n\t&#125;\n\t/**\n\t * @return the name\n\t */\n\tpublic String getName() &#123;\n\t\treturn name;\n\t&#125;\n\t/**\n\t * @param name the name to set\n\t */\n\tpublic void setName(String name) &#123;\n\t\tthis.name = name;\n\t&#125;\n\t/**\n\t * @return the score\n\t */\n\tpublic int getScore() &#123;\n\t\treturn score;\n\t&#125;\n\t/**\n\t * @param score the score to set\n\t */\n\tpublic void setScore(int score) &#123;\n\t\tthis.score = score;\n\t&#125;\n\tpublic static int compareStudentByScore(Studente student1,Studente student2) &#123;\n\t\treturn student1.getScore()-student2.getScore();\n\t&#125;\n\tpublic static int compareStudentByName(Studente student1,Studente student2) &#123;\n\t\treturn student1.getName().compareToIgnoreCase(student2.getName());\n\t&#125;\n\tpublic int compareByScore(Studente student1) &#123;\n\t\treturn this.getScore()-student1.getScore();\n\t&#125;\n\tpublic int compareByName(Studente student1) &#123;\n\t\treturn this.getName().compareTo(student1.getName());\n\t&#125;\n&#125;\n\njdk8接口引入默认方法的原因1.接口中的默认方法不会让你去实现,因为已经有写好的方法体\n2.接口中设计默认方法好处是有很好的兼容性,以前的代码假如使用了一个接口,那么现在你再在这个接口上新加一个\n抽象方法那么就必须又要实现,要是这么回事的话,很老的项目岂不是还需要一个一个手动实现方法,所有有了默认方\n法不需要去实现,直接就继承了\n\nStream流1.源\n2.零个或多个中间操作\n3.终止操作\nCollection提供了新的stream()方法\n流不存储值,通过管道的方式获取值\n本质是函数式的,对流的操作会生产一个结果,不过并不会修改底层的数据源,集合可以作为流的底层数据源\n延迟查找,很多流操作(过滤,映射,排序等)都可以延迟实现\n\n1.和迭代器又不同的是, Stream可以并行化操作,迭代器只能命令式地、串行化操作\n2.当使用串行方式去遍历时,每个item读完后再读下一个 item\n3.使用并行去遍历时,数据会被分成多个段,其中每一个都在不同的线程中处理,然后将结果一起输出Stream的并行操作依赖于Java7中引入的Fork&#x2F;Join框架\n\n流操作的分类1.惰性求值\n2.及早求值\n\nStream创建的方式import java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Stream;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月26日 下午2:59:33   \n* @version\n */\npublic class StreamTest &#123;\n\t@SuppressWarnings(\"all\")\n\tpublic static void main(String[] args) &#123;\n\t\t//传入多个元素\n\t\tStream stream=Stream.of(\"lvshihao\",\"zhangying\",\"liuxinyu\");\n\t\tString[] arr=new String[] &#123;\"lvshihao\",\"zhangying\",\"liuxinyu\"&#125;;\n\t\t//传入一个数组\n\t\tStream stream2=Arrays.stream(arr);\n\t\t//获取一个集合的流\n\t\tList&lt;String> asList = Arrays.asList(arr);\n\t\tStream stream3=asList.stream();\n\t&#125;\n&#125;\n\nStream的基本使用import java.util.stream.IntStream;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月26日 下午4:03:01   \n* @version\n */\npublic class IntStreamTest &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tIntStream.of(new int[] &#123;44,5,6,7,9,5&#125;).forEach(System.out::println);;\n\t\tSystem.out.println(\"---------------\");\n\t\t//包前不包尾\n\t\tIntStream.range(3,6).forEach(System.out::println);\n\t\tSystem.out.println(\"---------------\");\n\t\t//包前包尾\n\t\tIntStream.rangeClosed(3,6).forEach(System.out::println);\n\t\t\n\t\t//使用Lambda表达式一行代码计算所有值相加的和\n\t\tint reduce = IntStream.rangeClosed(1,100).reduce(0,Integer::sum);\n\t\tSystem.out.println(reduce);\n\t&#125;\n&#125;\n\n\nStream深度解析import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.TreeSet;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月27日 上午9:23:45   \n* @version\n */\npublic class StreamTest2 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tStream&lt;String> stream=Stream.of(\"lvshihao\",\"lvshihao1\",\"lvshihao2\");\n\t\tString[] array = stream.toArray(String[]::new);\n\t\tArrays.asList(array).forEach(System.out::println);\n\t\t\n\t\tStream&lt;String> stream1=Stream.of(\"lvshihao\",\"lvshihao1\",\"lvshihao2\");\n\t\tList&lt;String> collect = stream1.collect(()->new ArrayList&lt;>(),(item,v2)->item.add(v2), (item1,item2)->item1.addAll(item2));\n\t\tcollect.forEach(System.out::println);\n\t\t\n\t\tStream&lt;String> stream2=Stream.of(\"lvshihao\",\"lvshihao1\",\"lvshihao2\");\n\t\tArrayList&lt;String> collect2 = stream2.collect(ArrayList::new, List::add,List::addAll);\n\t\tcollect2.forEach(System.out::println);\n\t\t\n\t\tStream&lt;String> stream3=Stream.of(\"lvshihao\",\"lvshihao1\",\"lvshihao2\");\n\t\tList&lt;String> collect3 = stream3.collect(Collectors.toList());\n\t\tcollect3.forEach(System.out::println);\n\t\t\n\t\tStream&lt;String> stream4=Stream.of(\"lvshihao\",\"lvshihao1\",\"lvshihao2\");\n\t\tList&lt;String> collect4 = stream4.collect(Collectors.toCollection(ArrayList::new));\n\t\tcollect4.forEach(System.out::println);\n\t\t\n\t\tStream&lt;String> stream5=Stream.of(\"lvshihao\",\"lvshihao1\",\"lvshihao2\");\n\t\tTreeSet&lt;String> collect5 = stream5.collect(Collectors.toCollection(TreeSet::new));\n\t\tcollect5.forEach(System.out::println);\n\t\t\n\t\tStream&lt;String> stream6=Stream.of(\"lvshihao\",\"lvshihao1\",\"lvshihao2\");\n\t\tString string = stream6.collect(Collectors.joining()).toString();\n\t\tOptional.of(string).ifPresent(System.out::println);\n\t&#125;\n&#125;\n\nStream实例剖析import java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.UUID;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\n/**\n* 个性签名：今天的努力只要对得起自己就满足了\n* 创建人：吕世昊  \n* 创建时间：2019年3月28日 下午2:48:55   \n* @version\n */\npublic class StreamTest3 &#123;\n\tpublic static void main(String[] args) &#123;\n\t\tList&lt;String> asList = Arrays.asList(\"lvshihao\",\"zhangying\",\"saaa\");\n\t\tasList.stream().map((v)->v.toUpperCase()).collect(Collectors.toList()).forEach(System.out::println);\n\t\tOptional.of(\"-------------------------\").ifPresent(System.out::println);\n\t\tList&lt;Integer> list=Arrays.asList(1,5,6,7,8,9);\n\t\tlist.stream().map(v->v*v).collect(Collectors.toList()).forEach(System.out::println);\n\t\tOptional.of(\"-------------------------\").ifPresent(System.out::println);\n\t\t\n\t\t//在流中操作多个集合,然和再解析成流在进行使用\n\t\tStream&lt;List&lt;Integer>> of = Stream.of(Arrays.asList(1),Arrays.asList(2,3),Arrays.asList(4,5,6));\n\t\tof.flatMap(v->v.stream()).map(x->x*x).forEach(System.out::println);\n\t\t\n\t\tOptional.of(\"-------------------------\").ifPresent(System.out::println);\n\t\tStream&lt;String> stream=Stream.empty();\n\t\tstream.findFirst().ifPresent(System.out::println);\n\t\t\n\t\tOptional.of(\"-------------------------\").ifPresent(System.out::println);\n\t\tStream&lt;String> stream1=Stream.generate(UUID.randomUUID()::toString);\n\t\tstream1.findFirst().ifPresent(System.out::println);\n\t\t\n\t\t\n\t\tOptional.of(\"找出该流中大于2的元素,然后将每个元素乘以2,然后忽略掉流中的前两个元素,然后再取流中的前两个元素,最后求出流中元素的总和\").ifPresent(System.out::println);\n\t\tStream.iterate(1,item->item+2).limit(6).forEach(System.out::println);\n\t\tOptional.of(\"-------------------------\").ifPresent(System.out::println);\n\t\tStream.iterate(1,item->item+2).limit(6).filter(v->v>2).forEach(System.out::println);\n\t\tOptional.of(\"-------------------------\").ifPresent(System.out::println);\n\t\tStream.iterate(1,item->item+2).limit(6).filter(v->v>2).map(value->value*2).forEach(System.out::println);\n\t\tOptional.of(\"-------------------------\").ifPresent(System.out::println);\n\t\tStream.iterate(1,item->item+2).limit(6).filter(v->v>2).map(value->value*2).skip(2).forEach(System.out::println);\n\t\tOptional.of(\"-------------------------\").ifPresent(System.out::println);\n\t\tStream.iterate(1,item->item+2).limit(6).filter(v->v>2).map(value->value*2).skip(2).limit(2).forEach(System.out::println);\n\t\tOptional.of(\"-------------------------\").ifPresent(System.out::println);\n\t\tInteger reduce = Stream.iterate(1,item->item+2).limit(6).filter(v->v>2).map(value->value*2).skip(2).limit(2).reduce(0,(v,v2)->v+v2);\n\t\tOptional.of(reduce).ifPresent(System.out::println);\n\t&#125;\n&#125;\n\n内部迭代与外部迭代本质剖析集合关注的是数据与数据存储本身;\n流关注的则是对数据的计算.\n流与迭代器类似的一点是:流是无法重复使用或消费的。\n\nStream的分区和分组用法package com.lvshihao.service;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\n/**\n * 功能描述\n *\n * @author 吕世昊\n * @date $\n * @describe 想成为世界最厉害的程序员\n * @email 202252197@qq.com\n * @signature 我的梦想---兰博基尼&#123;奋斗&#125;\n */\npublic class StreamTest &#123;\n    public static void main(String[] args) &#123;\n        User user=new User(1,\"ll\",5);\n        User user1=new User(2,\"lla\",5);\n        User user11=new User(3,\"ll\",52);\n        List&lt;User> asList =new ArrayList&lt;>(Arrays.asList(user,user1,user11));\n        //对数据进行分组\n        Map&lt;Integer, List&lt;User>> collect2 = asList.stream().collect(Collectors.groupingBy(User::getAge));\n        System.out.println(collect2);\n        //对数据进行分组,返回组内数据的个数\n        Map&lt;Integer, Long> collect = asList.stream().collect(Collectors.groupingBy(User::getAge,Collectors.counting()));\n        System.out.println(collect);\n        //对数据进行分组,返回组内指定元素的平均值\n        Map&lt;String, Double> collect3 = asList.stream().collect(Collectors.groupingBy(User::getName,Collectors.averagingInt(User::getAge)));\n        System.out.println(collect3);\n        //对数据进行分区一共有两区true和false\n        Map&lt;Boolean, List&lt;User>> collect1 = asList.stream().collect(Collectors.partitioningBy(v -> v.getAge() > 6));\n        System.out.println(collect1);\n        //对数据进行二次分区\n        Map&lt;Boolean, Map&lt;Boolean, List&lt;User>>> collect4 = asList.stream().collect(Collectors.partitioningBy(v -> v.getAge() > 6, Collectors.partitioningBy(vc -> vc.getId() > 1)));\n        System.out.println(collect4);\n\n    &#125;\n&#125;\nclass User&#123;\n    @Override\n    public String toString() &#123;\n        return \"User&#123;\" +\n                \"id=\" + id +\n                \", name='\" + name + '\\'' +\n                \", age=\" + age +\n                '&#125;';\n    &#125;\n\n    private int id;\n    private String name;\n    private int age;\n\n    public User() &#123;\n    &#125;\n\n    public User(int id, String name, int age) &#123;\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    &#125;\n\n    public int getId() &#123;\n        return id;\n    &#125;\n\n    public void setId(int id) &#123;\n        this.id = id;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n    public int getAge() &#123;\n        return age;\n    &#125;\n\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n&#125;\n\n","slug":"java8新特性","date":"2023-04-04T06:57:12.703Z","categories_index":"","tags_index":"","author_index":"吕世昊"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2023-04-04T04:40:14.036Z","categories_index":"","tags_index":"","author_index":"吕世昊"}]